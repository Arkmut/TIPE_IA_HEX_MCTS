# -*- coding: utf-8 -*-
import random as rd
import numpy as np
import Classes_neurones 
import sympy as sp

def faire_reseau(liste_couches,nb_data):
#    n = len(liste_couches)
    reseau = []
    precouche = []
    for k in range(liste_couches[0]):
        listpoids = np.random.rand(nb_data)
        precouche.append(NeuroneAlpha(listpoids,rd.randint(0,1)))
    reseau.append(precouche)
    for k in range(1,len(liste_couches)):
        couche = []
        precouche = reseau[k-1]
        for i in range(liste_couches[k]):
            listpoids = np.random.rand(len(precouche))
            if (len(listpoids)!= len(precouche)):
                print('nok')
            couche.append(Neurone(precouche,listpoids,rd.randint(0,1)))
        reseau.append(couche)
    return reseau

def evaluer_reseau(reseau, data): 
    return reseau[-1][0].evalue(data)

def affiche_reseau(reseau):
    n = len(reseau)
    for k in range(n):
        m = len(reseau[k])
        for i in range(m):
            print("    "*k,"couche",k,"numero",i)

def affiche_poids(reseau):
    n = len(reseau)
    for k in range(n):
        m = len(reseau[k])
        for i in range(m):
            print("     "*k,reseau[k][i].poids,"\n")


#prend la matrice d'un plateau en entrée, et la transforme en vecteur ligne  
def platarray(platmat):
    mat = np.array(platmat)
    print(mat,type(mat))
    n = len(platmat)
    m = len(platmat[0])
    print(n,m)
    mat2 = np.reshape(mat,n*m)
    return mat2
    
def platlist(mat):
    l = []
    for k in range(len(mat)-1):
        for i in range(len(mat[k])-1):
            l.append(mat[k][i])
    return l




"""Ici, le problème est de pouvoir selectionner des poids aléatoirement et de les modifier. Il faut ainsi garder en mémoire les 
neurones auquels ils appartiennent. On utilise le fait que les liste des poids sont des pointeurs."""     
def sgd(nbTours,nbechant,reseau,const,cout):
#    print('avant',reseau[0][0].poids())
    for k in range(nbTours):
        selectNeur = platlist(reseau)
        rd.shuffle(selectNeur)
        n1 = len(selectNeur)
        matpoids = [selectNeur[k].poids() for k in range(len(selectNeur)-1)]
        n2 = len(matpoids)
        poidselect = [(rd.randint(0,n1-1),rd.randint(0,len(matpoids)-1)) for _ in range(n2 - 1)]#couple de coordonnées aléatoires
        for k in range(n2 -1):
            x,y = poidselect[k]
            matpoids[x][y] = matpoids[x][y] - (const/nbechant)*dp(cout,matpoids[x][y])
            



        
#calcul de la dérivée partielle     
def dp(fonction, variable):
    return 1
